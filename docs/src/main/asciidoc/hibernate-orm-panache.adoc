////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
////
= Using simplified Hibernate ORM with Panache


include::./attributes.adoc[]
:config-file: application.properties
//:COMM:
:ENT:

ifdef::ENT[]
As a Java developer, you can use Hibernate ORM with Panache to simplify persistence with your {ProductName} applications.
endif::ENT[]

ifdef::COMM[]
You can use Hibernate ORM with Panache to simplify persistence with your {ProductName} applications.
endif::COMM[]


.Prerequisites
* You have a {ProductName} Maven project configured with a Java database connectivy (JDBC) datasource and Hibernate ORM.
+
NOTE: If you not define a JDBC driver, Hibernate ORM with Panache will not work.

ifdef::ENT[]
// Note that before this document is published, the community documents linked below must be productized and the links replaced with the product document links.
* For information about creating a {ProductName} Maven project, see https://access.redhat.com/documentation/en-us///red_hat_build_of_quarkus/{ProductVersion}/html-single/creating_quarkus_applications_with_apache_maven/[_Creating Quarkus applications with Apache Maven_].
endif::ENT[]

ifdef::COMM[]
* For information about creating a {ProductName} Maven project, see https://quarkus.io/guides/maven-tooling[_Quarkus - Building Applications with Maven_].
endif::COMM[]

* For information about configuring your {ProductName} Maven project with a JDBC datasource, see https://quarkus.io/guides/datasource[_Quarkus - Configuring your datasources_].
* For information about configuring your {ProductName} Maven project Hibernate ORM, see https://quarkus.io/guides/hibernate-orm[_Quarkus - Quarkus - Hibernate ORM and JPA_].

For an example of a completed {ProductName} Maven project that uses the Panache extension, see the https://github.com/quarkusio/quarkus-quickstarts/tree/master/hibernate-orm-panache-quickstart[Hibernate ORM Panache Quickstart].


== Hibernate ORM with Panache extension

Hibernate ORM is the most widely used JPA implementation. It provides all of the features of an ORM but it is not easy use Hibernate for the simple operations that make up the majority of persistence coding requirements.  For a simple implementation with the most common data mappings you can use the Hibernate ORM with Panache extension to write more concise code.

The Hibernate ORM with Panache extension eliminates the following Hibernate ORM issues:

* *Duplicate ID logic*
+
You use the `PanacheEntity` class to create entities. Because the ID is defined automatically in the `PanacheEntity` class, you do not need to define it in your `PanacheEntity` instance. However, you can specify your own ID in your instance if you prefer.  If you require a custom ID strategy, you can extend the `PanacheEntityBase` class instead.

* *Useless `getter` and `setter` functions*
+
Because Java does not support properties, when you write Java code you must create fields and then generate `getter` and `setter` functions for those fields, even if all you need to do is read or write to the field. With Panache, if you define a field as a public field and then read or write to that field, Panache generates the required `getter` and `setter` functions. In addition, you can write other accessors as required.
* *Entity definitions split from operations*
+
In the traditional Java EE model, you put the the entity definition in one class, the model, and the operations performed on the model in another class, the data access object (DAO) or repository. The Panache active record method enables you to create the entity definition and the repository in the same class.

* *Verbose Hibernate queries*
+
Panache provides Hibernate Query Language (HQL) shortcuts to simplify your queries. You do not write parts of the query that you do not need.




=== Using the Panache active record pattern


When you use Hiberate ORM, you must create two classes that separate the state and its operations even though you would never do that for regular Java objects where state and methods are in the same class. In addition to requiring two classes, Hibernate ORM requires you to  inject the repository where you need to perform entity operations, which breaks your edit flow and requires you to get out of the code that you are  writing to set up an injection point before coming back to use it.

You can use the Panache active record pattern with the `PanacheEntity` class to keep the model and the repository together.

.Procedure

. Add the Hibernate ORM with Panache extension dependency to your {ProductName} project `pom.xml` file:
+
[source,java]
----
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-hibernate-orm-panache</artifactId>
    </dependency>
</dependencies>
----

+
. To define an entity, create a class that extends the `PanacheEntity` class, annotate it with `@Entity`, and add your
columns as public fields. The following example creates and annotates the `Person` class:
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;
}
----
+
. Optional: To specify that a field not persist, use the `@Transient` annotation. The following example annotates the `status` field with `@Transient`.
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;

    @Transient
    public Status status;
}
----
. Add any additional accessors. The following example adds an accessor that returns `name` as uppercase in the model and an accessor that stores all names in lowercase in the database.

+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;

    @Transient
    public Status status;

    public String getName(){
        return name.toUpperCase();
    }
    public void setName(String name){
        this.name = name.toLowerCase();
    }
}
----
+
In this example, when users access `person.name` they call the `getName()` accessor and when they call the `setName()` they set the value of `name`. This enables correct encapsulation at runtime because all field calls are replaced with the corresponding `getter` and `setter` calls.
. Add custom queries to your entities as static methods inside the entities themselves so queries are co-located with the object they operate on. The following example adds three custom queries, `findByName`, `findAlive`, and `deleteStefs`:
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("name", name).firstResult();
    }

    public static List<Person> findAlive(){
        return list("status", Status.Alive);
    }

    public static void deleteStefs(){
        delete("name", "Stef");
    }
}
----




=== Panache active record pattern common operations
This section lists common Panache active record pattern operations. These examples use a `Person` entity which extends the `PanacheEntity` class.

* Create an entity:
+
[source,java]
----
Person person = new Person();
person.name = "Stef";
person.birth = LocalDate.of(1910, Month.FEBRUARY, 1);
person.status = Status.Alive;
----

* Persist an entity:
+
[source,java]
----
person.persist();
----

+
NOTE: After an entity is persisted, you do not need to explicitly save your entity. All changes are automatically persisted on transaction commit.

* Verify that an entity is persisted:
+
[source,java]
----
if(person.isPersistent())
----

* Delete an entity:
+
[source,java]
----
person.delete();
----



* Retrieve a list of all `Person` entities:
+
[source,java]
----
List<Person> allPersons = Person.listAll();
----

* Find a specific person by ID:
+
[source,java]
----
person = Person.findById(personId);
----

* Find a specific person by ID using the `Optional` class:
+
[source,java]
----
Optional<Person> optional = Person.findByIdOptional(personId);
person = optional.orElseThrow(() -> new NotFoundException());
----



* Find all living persons:
+
[source,java]
----
List<Person> livingPersons = Person.list("status", Status.Alive);
----

* Count all persons:
+
[source,java]
----
long countAll = Person.count();
----

* Count all living persons:
+
[source,java]
----
long countAlive = Person.count("status", Status.Alive);
----


* Delete all living persons:
+
[source,java]
----
Person.delete("status", Status.Alive);
----



* Delete all persons:
+
[source,java]
----
Person.deleteAll();
----

* Delete by ID:
+
[source,java]
----
boolean deleted = Person.deleteById(personId);
----

* Set the name of all living persons to Mortal:
+
[source,java]
----
Person.update("name = 'Mortal' where status = ?1", Status.Alive);
----

All `List` methods have equivalent `stream` methods, which requires a transaction to work as shown in the following example:

[source,java]
----
Stream<Person> persons = Person.streamAll();
List<String> namesButEmmanuels = persons
    .map(p -> p.name.toLowerCase() )
    .filter( n -> ! "emmanuel".equals(n) )
    .collect(Collectors.toList());
----


=== Using the Panache repository pattern
Panache enables you to create entities that contain the model and repository in a single class. However, if you prefer to create a separate class for the model and a separate class for the repository and still have the other benefits of Panache, for example having the `getters` and `setter` automatically generate, you can use the repository pattern.

.Procedure.


. Add the Hibernate ORM with Panache extension dependency to your {ProductName} project `pom.xml` file:
+
[source,java]
----
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-hibernate-orm-panache</artifactId>
    </dependency>
</dependencies>
----

. Define entities as JPA entities. The following example defines the `Person` class as a JPA entity.
+
[source,java]
----
@Entity
public class Person {
    @Id @GeneratedValue private Long id;
    private String name;
    private LocalDate birth;
    private Status status;

    public Long getId(){
        return id;
    }
    public void setId(Long id){
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public LocalDate getBirth() {
        return birth;
    }
    public void setBirth(LocalDate birth) {
        this.birth = birth;
    }
    public Status getStatus() {
        return status;
    }
    public void setStatus(Status status) {
        this.status = status;
    }
}
----
. Define your repository and add instance methods. The following example defines the `PersonRepository` :
+
[source,java]
----
@ApplicationScoped
public class PersonRepository implements PanacheRepository<Person> {

   public Person findByName(String name){
       return find("name", name).firstResult();
   }

   public List<Person> findAlive(){
       return list("status", Status.Alive);
   }

   public void deleteStefs(){
       delete("name", "Stef");
  }
}
----

+
. Add the following code to the REST endpoint where you want to use entity operations so that the operations that are defined in `PanacheEntityBase` are available:
+
[source,java]
----
@Inject
PersonRepository personRepository;

@GET
public long count(){
    return personRepository.count();
}
----

=== Panache repository pattern common operations
This section lists common Panache repository pattern operations. These  examples use a regular JPA `Person` entity and the `PersonRepository` class which implements the `PanacheRepository` interface.

* Create an entity:
+
[source,java]
----
Person person = new Person();
person.setName("Stef");
person.setBirth(LocalDate.of(1910, Month.FEBRUARY, 1));
person.setStatus(Status.Alive);
----

* Persist an entity:
+
[source,java]
----
personRepository.persist(person);
----
+
NOTE: After an entity is persisted, you do not need to explicitly save your entity. All changes are automatically persisted on transaction commit.

* Verify that an entity is persisted:
+
[source,java]
----
if(personRepository.isPersistent(person))
----

* Delete an entity:
+
[source,java]
----
personRepository.delete(person);
----

* Retrieve a list of all `Person` entities:
+
[source,java]
----
List<Person> allPersons = personRepository.listAll();
----
* Find a specific person by ID:
+
[source,java]
----
person = personRepository.findById(personId);
----

* Find a specific person by ID using the `Optional` class:
+
[source,java]
----
Optional<Person> optional = personRepository.findByIdOptional(personId);
person = optional.orElseThrow(() -> new NotFoundException());
----

* Find all living persons:
+
[source,java]
----
List<Person> livingPersons = personRepository.list("status", Status.Alive);
----

* Count all persons:
+
[source,java]
----
long countAll = personRepository.count();
----

* Count all living persons:
+
[source,java]
----
long countAlive = personRepository.count("status", Status.Alive);
----

* Delete all living persons:
+
[source,java]
----
personRepository.delete("status", Status.Alive);
----


* Delete all persons:
+
[source,java]
----
personRepository.deleteAll();
----

* Delete by ID:
+
[source,java]
----
boolean deleted = personRepository.deleteById(personId);
----

* Set the name of all living persons to Mortal:
+
[source,java]
----
personRepository.update("name = 'Mortal' where status = ?1", Status.Alive);
----

All `List` methods have equivalent `stream` methods, which requires a transaction to work as shown in the following example:

[source,java]
----
Stream<Person> persons = personRepository.streamAll();
List<String> namesButEmmanuels = persons
    .map(p -> p.name.toLowerCase() )
    .filter( n -> ! "emmanuel".equals(n) )
    .collect(Collectors.toList());
----




== Hibernate ORM with Panache queries

Hibernate Query Language (HQL) is a query language similar to Structured Query Language (SQL). However, HQL works with persistent objects and properties instead of tables and columns. For more information about HQL, see the "HQL and JPQL" section of the xref:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html[_Hibernate ORM User Guide_].


=== Simplified Hibernate ORM with Panache queries
You can use HQL to write queries for Hibernate ORM with Panache entities, as shown in the following example:

[source,java]
----
Order.find("select distinct o from Order o left join fetch o.lineItems");
Order.update("update from Person set name = 'Mortal' where status = ?", Status.Alive);
----

However, Hibernate ORM with Panache provides several HQL short cuts.

.FROM
In most cases, HQL `SELECT` statements are immediately followed by the `FROM` clause, for example `SELECT name FROM _ENTITY_NAME_`, where `_ENTITY_NAME_` is the name of a Java entity. However, if you do not include `FROM` in your HQL `SELECT` statement, Panache adds `FROM` in the following cases:

[cols="30%,70%" options="header"]

|===
h|Statement starts with
h|Statement expands to

|`ORDER BY`
|`FROM _ENTITY_NAME_ ORDER BY`

| A single column name and a single parameter `_SINGLE_COLUMN_NAME_`
|`FROM _ENTITY_NAME_ WHERE  _SINGLE_COLUMN_NAME_  =?`


| A query string (_QUERY_STRING_)
| `FROM _ENTITY_NAME_ WHERE  _QUERY_STRING_`


|===


.UPDATE

If you do not include `UPDATE` in your HQL `SELECT` statement, Panache adds `UPDATE` in the following cases:

[cols="30%,70%" options="header"]

|===
h|Statement starts with
h|Statement expands to

|`FROM _ENTITY_NAME_`
|`UPDATE FROM _ENTITY_NAME_`

| `set? _SINGLE_COLUMN_NAME_`, where  `_SINGLE_COLUMN_NAME_` is a single column name and a single parameter
| `UPDATE FROM _ENTITY_NAME_ set _SINGLE_COLUMN_NAME_ =?`


| `set? _QUERY_STRING_`, where  `_QUERY_STRING_`is a query string
| `UPDATE FROM _ENTITY_NAME_ set _QUERY_STRING_`

|===



=== PanacheQuery entity

The `PanacheQuery` entity  abstracts the use of paging, getting the number of results, and operating on `List` or `Stream` methods. You can use the `PanacheQuery` entity  for paging and range-based queries.


Only use `list` and `stream` methods if your table contains small data sets. For large data
sets, use the `find` method equivalents, which return a `PanacheQuery` on which you can perform paging.

[WARNING]
====
You cannot mix ranges and pages. If your query uses a range, any methods that depend on having a current page throw an `UnsupportedOperationException` exception. To switch back to paging, use `page(Page)` or `page(int, int)`.
====

.Additional resources
* For a complete list of  `PanacheQuery` methods, see the https://javadoc.io/doc/io.quarkus/quarkus-hibernate-orm-panache/latest/io/quarkus/hibernate/orm/panache/PanacheQuery.html[_PanacheQuery Class_] page.

==== Examples of queries that use paging
These examples show how you can use paging in your Panache queries. The active record pattern examples use a `Person` entity which extends the `PanacheEntity` class. The repository pattern examples use a regular JPA `Person` entity and the `PersonRepository` class which extends the
`PanacheRepository` class.



* Create a query for all living persons:
** Active record pattern:
+
[source,java]
----
PanacheQuery<Person> livingPersons = Person.find("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
PanacheQuery<PersonRepository> livingPersons = personRepository.find("status", Status.Alive);
----


* Make pages have 25 entries per page:
+
[source,java]
----
livingPersons.page(Page.ofSize(25));
----


* Retrieve the first page:
+
[source,java]
----
List<Person> firstPage = livingPersons.list();
----

* Retrieve the second page:
** Active record pattern:
+
[source,java]
----
List<Person> secondPage = livingPersons.nextPage().list();
----
** Repository pattern:
+
[source,java]
----
List<PersonRepository> secondPage = livingPersons.nextPage().list();
----

* Retrieve page 7:
** Active record pattern:
+
[source,java]
----
List<Person> page7 = livingPersons.page(Page.of(7, 25)).list();
----
** Repository pattern:
+
[source,java]
----
List<PersonRepository> page7 = livingPersons.page(Page.of(7, 25)).list();
----

* Retrieve the number of pages:
+
[source,java]
----
int numberOfPages = livingPersons.pageCount();
----

* Retrieve the total number of entities returned by this query without paging:
[source,java]
----
int count = livingPersons.count();
----

* Chain methods together:
** Active record pattern:
+
[source,java]
----
return Person.find("status", Status.Alive)
   .page(Page.ofSize(25))
   .nextPage()
   .stream()
----
** Repository pattern:
+
[source,java]
----
return PersonRepository.find("status", Status.Alive)
   .page(Page.ofSize(25))
   .nextPage()
   .stream()
----

==== Examples of queries that use a range of values
These examples show how you can use a range of values in your Panache queries. The active record pattern examples use a `Person` entity which extends the `PanacheEntity` class. The repository pattern examples use a regular JPA `Person` entity and the `PersonRepository` which extends the
`PanacheRepository` class.


* Create a query for all living persons:
** Active record pattern:
+
[source,java]
----
PanacheQuery<Person> livingPersons = Person.find("status", Status.Alive);
----
** Repository pattern:
+
[source,java]
----
PanacheQuery<PersonRepository> livingPersons = personRepository.find("status", Status.Alive);
----

* Specify a range from index 0 to index 24 (inclusive):
+
[source,java]
----
livingPersons.range(0, 24);
----

* Specify a range called `firstRange` with the range index 0 to index 24 (inclusive):
** Active record pattern:
+
[source,java]
----
List<Person> firstRange = livingPersons.list();
----
** Repository pattern:
+
[source,java]
----
List<PersonRepository> firstRange = livingPersons.list();
----

* Specify a new range called `secondRange` with the range index 25 to index 49 (inclusive):
** Active record pattern:
+
[source,java]
----
List<Person> secondRange = livingPersons.range(25, 49).list();
----

** Repository pattern:
+
[source,java]
----
List<PersonRepository> secondRange = livingPersons.range(25, 49).list();
----



== Named queries

A named query is a statically defined query with an unchangeable query string annotated with the Hibernate ORM `@NamedQuery` annotation. With Panache, you can reference a named query from the `find` method. For a named query to work within the context of Panache, it must be defined inside of a `PanacheEntity` class or a `PanacheRepository` class or a super class of one of these classes.

.Prerequisites
* A `PanacheEntity` or a `PanacheRepository` class exists.

.Procedure

. Add the `@NamedQuery` annotation to a Panache entity.
. In the `find` method, prefix the named query with `#`.
+
The following example creates the `Person.getByName` query and uses it in the `find` method:
+
[source,java]
----
@Entity
@NamedQuery(name = "Person.getByName", query = "from Person where name = :name")
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("#Person.getByName", name).firstResult();
    }
}
----

=== Query parameters

You can pass query parameters by using 1-based indexing, by creating a map, or by creating an instance of the `Parameter` class.

* *1-based indexing example*:
[source,java]
----
Person.find("name = ?1 and status = ?2", "stef", Status.Alive);
----

* *Map example*:

[source,java]
----
Map<String, Object> params = new HashMap<>();
params.put("name", "stef");
params.put("status", Status.Alive);
Person.find("name = :name and status = :status", params);
----

* *`Parameters` class examples*:
** Generate a map:
+
[source,java]
----

Person.find("name = :name and status = :status",
         Parameters.with("name", "stef").and("status", Status.Alive).map());
----
** Use as-is:
+
[source,java]
----
Person.find("name = :name and status = :status",
         Parameters.with("name", "stef").and("status", Status.Alive));
----

=== Sorting

The following examples demonstrate different ways to sort.

* Methods that accept a query string also accept the following simplified query form:
+
[source,java]
----
List<Person> persons = Person.list("order by name,birth");
----

* Methods that accept a query string accept an optional `Sort` parameter, which enables you to abstract your sorting:
** Sort example 1
+
[source,java]
----
List<Person> persons = Person.list(Sort.by("name").and("birth"));
----
** Sort example 2
+

[source,java]
----
List<Person> persons = Person.list("status", Sort.by("name").and("birth"), Status.Alive);
----

The `Sort` class has many methods for adding columns and specifying sort direction.

=== Query projection

You can perform query projection with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods. You can use it to restrict which fields will be returned by the database. Hibernate uses data transfer object (DTO) projection and generates a `SELECT` clause with the attributes from the projection class. This is also called _dynamic instantiation_ or _constructor expression_. For more information, see "The SELECT clause" section of the
link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html[_Hibernate_User_Guide_].

The projection class must be a valid Java Bean and have a constructor that contains all of its attributes. This constructor will be used to instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.

The following example shows how to perform query projection:

[source,java]
----
import io.quarkus.runtime.annotations.RegisterForReflection;

@RegisterForReflection
public class PersonName {
    public final String name;

    public PersonName(String name){
        this.name = name;
    }
}

PanacheQuery<PersonName> query = Person.find("status", Status.Alive).project(PersonName.class);
----

This example uses public fields, but you can use private fields and `getters` and `setters` if you prefer. The `public final String name;` constructor is used by Hibernate. You must have only one constructor in your class and all of the class attributes must be parameters. Only `name` will be loaded from the database.

ifdef::COMM[]
NOTE: If you plan to deploy your application as a native executable, you must manually register the projection class for reflection.
endif::COMM[]


[WARNING]
====
The implementation of the `project(Class)` method uses the constructor's parameter names to build the select clause of the query,
so the compiler must be configured to store parameter names inside the compiled class.
This is enabled by default if you are using the Quarkus Maven archetype. If you are not using it, add the property `<maven.compiler.parameters>true</maven.compiler.parameters>` to your `pom.xml` file.
====

== Transactions

Wrap methods that modify your database, for example `entity.persist()`, within a transaction. When you do this, the JPA will batch any changes that you make to you entities at the end of the transaction or before a query. This process is called a flush. It is the most efficient way to persist changes.


NOTE: If you want to check optimistic locking failures, perform object validation right away, or get immediate feedback, you can force the flush operation by calling `entity.flush()` or use `entity.persistAndFlush()` to make it a single method call. This enables you to catch any `PersistenceException` errors that occur when JPA sends changes to the database. However, this method is not efficient and transactions must still be committed.


.Procedure

To create a transaction, add the `@Transactional` annotation to your method at application entry point boundaries such as REST endpoint controllers.

The following example demonstrates the use of the flush method to allow a specific action in case of a `PersistenceException` error. This example uses the `persistAndFlush()` shorthand method on a Panache repository to persist to the database then flush the changes. The data is saved to disk in case of an error:
[source,java]
----
@Transactional
public void create(Parameter parameter){
    try {
        // Here the persistAndFlush() shorthand method is used on a Panache repository to persist to database then flush the changes.
        return parameterRepository.persistAndFlush(parameter);
    }
    catch(PersistenceException pe){
        LOG.error("Unable to create the parameter", pe);
        // In case of error, the data is saved to disk.
        diskPersister.save(parameter);
    }
}
----

== Panache lock management

Panache provides direct support for database locking with your entity or repository, using `findById(Object, LockModeType)` or `find().withLock(LockModeType)`. The following examples use  the active record pattern and the `Person` class. You can apply the same method to repositories.

.Locking using the `findById()` method

[source,java]
----
public class PersonEndpoint {

    @GET
    @Transactional
    public Person findByIdForUpdate(Long id){
        Person p = Person.findById(id, LockModeType.PESSIMISTIC_WRITE);
        // Perform some action. The lock will be released when the transaction ends.
        return person;
    }

}
----

.Locking in a `find()` method

[source,java]
----
public class PersonEndpoint {

    @GET
    @Transactional
    public Person findByNameForUpdate(String name){
        Person p = Person.find("name", name).withLock(LockModeType.PESSIMISTIC_WRITE).findOne();
        // Perform some action. The lock will be released when the transaction ends.
        return person;
    }

}
----

NOTE: Locks are released when the transaction ends, so the method that invokes the lock query must be annotated with the `@Transactional` annotation.

== Custom IDs

One of the advantages of Panache is that IDs are set automatically in the `PanacheEntityBase` and  `PanacheEntityRepositoryBase` classes. You can specify your own ID strategy by extending the `PanacheEntityBase` or `PanacheEntityRepositoryBase` class, depending on the entity method you are using.


.Procedure

. Create a class that extends `PanacheEntityBase`.
. Declare the ID you want as a public field. The following example extends the  `PanacheEntityBase` by creating the `Person` class.
+
[source,java]
----
@Entity
public class Person extends PanacheEntityBase {

    @Id
    @SequenceGenerator(
            name = "personSequence",
            sequenceName = "person_id_seq",
            allocationSize = 1,
            initialValue = 4)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "personSequence")
    public Integer id;

    //...
}
----

[NOTE]
====
If you are using repositories, extend the `PanacheRepositoryBase` class instead of the `PanacheRepository` class
and specify your ID type as an extra type parameter:

[source,java]
----
@ApplicationScoped
public class PersonRepository implements PanacheRepositoryBase<Person,Integer> {
    //...
}
----
====

== Defining entities in external projects or JAR files

Hibernate ORM with Panache relies on Java `bytecode` enhancements that are added to your entities at compile time. It attempts to identity archives with Panache entities and consumers of Panache entities by the presence of the `META-INF/panache-archive.marker` marker file. Panache includes an annotation processor that automatically creates this file in archives that depend on Panache, even if that dependency is indirect.

NOTE: If you have disabled annotation processors, you might need to create the `META-INF/panache-archive.marker` file manually.

If your project includes the `jpa-modelgen` annotation processor you must override it or the Panache annotation processor will be excluded.

.Prerequisites
* A {ProductName} Maven project that uses the Hibernate ORM with Panache extension is available.

.Procedure
To override the `jpa-modelgen` annotation processor, do one of the following tasks:

* Create the `META-INF/panache-archive.marker` file manually.
* Add the `quarkus-panache-common` annotation processor to your project's `pom.xml` file, as shown in the following example:
+
[source,xml]
----
<plugin>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>${compiler-plugin.version}</version>
    <configuration>
      <annotationProcessorPaths>
        <annotationProcessorPath>
          <groupId>org.hibernate</groupId>
          <artifactId>hibernate-jpamodelgen</artifactId>
          <version>${hibernate.version}</version>
        </annotationProcessorPath>
        <annotationProcessorPath>
          <groupId>io.quarkus</groupId>
          <artifactId>quarkus-panache-common</artifactId>
          <version>${quarkus.platform.version}</version>
        </annotationProcessorPath>
      </annotationProcessorPaths>
    </configuration>
</plugin>
----


== Mocking

If you want to test part of your project in isolation and that part has dependencies on other objects, you need to create stand-in objects for the dependencies so you can perform a unit test. These stand-ins are called a mock objects. Mockito is a popular mocking framework.



=== Using Mokito with the active record pattern

If you are using the Panache active record pattern, you cannot use the Mockito mocking framework directly because it does not support the mocking of static methods. To use Mokito with the active record pattern, use the `quarkus-panache-mock` extension. It enables you to use Mockito to mock all provided static methods, including methods that you create. This example shows you how to use Mokito to perform various tests on the `Person` entity.

.Prerequisites
* You have a {ProductName} Maven project that uses the Panache active record pattern for persistence.

.Procedure

. Add the `quarkus-panache-mock` extension dependency to your project's  `pom.xml` file:
+
[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-panache-mock</artifactId>
    <scope>test</scope>
</dependency>
----
. Create the `Person` entity:
+
[source,java]
----
@Entity
public class Person extends PanacheEntity {

    public String name;

    public static List<Person> findOrdered() {
        return find("ORDER BY name").list();
    }
}
----

. Create the following mocking test:
+
[source,java]
----
@QuarkusTest
public class PanacheFunctionalityTest {

    @Test
    public void testPanacheMocking() {
        PanacheMock.mock(Person.class);

        // Mocked classes always return a default value.
        Assertions.assertEquals(0, Person.count());

        // Specify the return value:
        Mockito.when(Person.count()).thenReturn(23l);
        Assertions.assertEquals(23, Person.count());

        // Change the return value:
        Mockito.when(Person.count()).thenReturn(42l);
        Assertions.assertEquals(42, Person.count());

        // Call the original method:
        Mockito.when(Person.count()).thenCallRealMethod();
        Assertions.assertEquals(0, Person.count());

        // Check that the method was called four times.
        PanacheMock.verify(Person.class, Mockito.times(4)).count();// <1>

        // Mock only with specific parameters:
        Person p = new Person();
        Mockito.when(Person.findById(12l)).thenReturn(p);
        Assertions.assertSame(p, Person.findById(12l));
        Assertions.assertNull(Person.findById(42l));

        // Mock throwing:
        Mockito.when(Person.findById(12l)).thenThrow(new WebApplicationException());
        Assertions.assertThrows(WebApplicationException.class, () -> Person.findById(12l));

        // Mock custom methods:
        Mockito.when(Person.findOrdered()).thenReturn(Collections.emptyList());
        Assertions.assertTrue(Person.findOrdered().isEmpty());

        PanacheMock.verify(Person.class).findOrdered();
        PanacheMock.verify(Person.class, Mockito.atLeastOnce()).findById(Mockito.any());
        PanacheMock.verifyNoMoreInteractions(Person.class);
    }
}
----

NOTE: Call your `verify` methods on `PanacheMock` rather than `Mockito`, otherwise you will not know
what mock object to pass.

=== Using Mokito with the repository pattern

If you are using the Panache repository pattern and the `quarkus-junit5-mockito` extension, you can use the Mockito mocking framework directly. This method makes mocking beans easier.

.Prerequisites
* You have a {ProductName} Maven project that uses the Panache repository pattern for persistence.

.Procedure
. Add the `quarkus-junit5-mockito` extension dependency to your project’s pom.xml file:
+
[source,java]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-junit5-mockito</artifactId>
    <scope>test</scope>
</dependency>
----

. Create the `Person` entity:
+
[source,java]
----
@Entity
public class Person {

    @Id
    @GeneratedValue
    public Long id;

    public String name;
}
----

. Create the `PersonRepository` repository:
+
[source,java]
----
@ApplicationScoped
public class PersonRepository implements PanacheRepository<Person> {
    public List<Person> findOrdered() {
        return find("ORDER BY name").list();
    }
}
----

. Create the following mocking test:
+
[source,java]
----
@QuarkusTest
public class PanacheFunctionalityTest {
    @InjectMock
    PersonRepository personRepository;

    @Test
    public void testPanacheRepositoryMocking() throws Throwable {

        // Mocked classes always return a default value
        Assertions.assertEquals(0, personRepository.count());

        // Specify the return value:
        Mockito.when(personRepository.count()).thenReturn(23l);
        Assertions.assertEquals(23, personRepository.count());

        // Change the return value:
        Mockito.when(personRepository.count()).thenReturn(42l);
        Assertions.assertEquals(42, personRepository.count());

        // Call the original method:
        Mockito.when(personRepository.count()).thenCallRealMethod();
        Assertions.assertEquals(0, personRepository.count());

        // Check that we called it 4 times
        Mockito.verify(personRepository, Mockito.times(4)).count();

        // Mock only with specific parameters:
        Person p = new Person();
        Mockito.when(personRepository.findById(12l)).thenReturn(p);
        Assertions.assertSame(p, personRepository.findById(12l));
        Assertions.assertNull(personRepository.findById(42l));

        // Mock throwing:
        Mockito.when(personRepository.findById(12l)).thenThrow(new WebApplicationException());
        Assertions.assertThrows(WebApplicationException.class, () -> personRepository.findById(12l));

        Mockito.when(personRepository.findOrdered()).thenReturn(Collections.emptyList());
        Assertions.assertTrue(personRepository.findOrdered().isEmpty());

        // Mock custom methods:
        Mockito.verify(personRepository).findOrdered();
        Mockito.verify(personRepository, Mockito.atLeastOnce()).findById(Mockito.any());
        Mockito.verifyNoMoreInteractions(personRepository);
    }
}
----
