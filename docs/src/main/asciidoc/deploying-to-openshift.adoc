[id='assembly_quarkus-openshift']

// AsciiDoc settings
:data-uri!:
:doctype: book
:experimental:
:idprefix:
:imagesdir: images
:numbered:
:sectanchors!:
:sectnums:
:sectlinks:
:source-highlighter: highlightjs
:toc: left
:linkattrs:
:toclevels: 3

// Name placeholders
:ProductLongName: Red Hat build of Quarkus
:ProductName: Quarkus
:ContextProduct: quarkus
:ProductVersion: 1.7
:ProductLongVersion: 1.7.5
:MavenVersion: 3.6.2
:JDKVersion: 11
:QuarkusPluginVersion: 1.7.5.Final-redhat-00007
:RHOSLong: Red Hat OpenShift Container Platform
:RHOSVersion: 4.5
:RHEL: Red Hat Enterprise Linux
:RHELVersion: 8

//Quarkus URLs

:URL_COMPONENT_FORMAT: html-single
:URL_COMPONENT_PRODUCT: red_hat_build_of_quarkus
:URL_BASE_QUARKUS: https://access.redhat.com/documentation/en-us/red_hat_build_of_quarkus/{ProductVersion}/{URL_COMPONENT_FORMAT}

:GETTING_STARTED_QUARKUS: Getting started with {PRODUCTLONGNAME}
:RELEASE_NOTES_QUARKUS: {PRODUCTLONGNAME} release notes
:MAVEN_QUARKUS: Creating {PRODUCTNAME} applications with Apache Maven
:OPENSHIFT_QUARKUS: Deploying {PRODUCTNAME} applications on {RHOSLong}
:CONFIGURATION_QUARKUS: Configuring {ProductName} applications
:TESTING_QUARKUS: Testing your {ProductName} Getting Started project
:NATIVE_EXECUTABLE_QUARKUS: Building a native executable with {PRODUCTLONGNAME}

:URL_RELEASE_NOTES: {URL_BASE_QUARKUS}/release_notes_for_{URL_COMPONENT_PRODUCT}_{ProductVersion}
:URL_GETTING_STARTED_QUARKUS: {URL_BASE_QUARKUS}/getting_started_with_{URL_COMPONENT_PRODUCT}
:URL_MAVEN_QUARKUS: {URL_BASE_QUARKUS}/creating_quarkus_applications_with_apache_maven
:URL_OPENSHIFT_QUARKUS: {URL_BASE_QUARKUS}/deploying_quarkus_applications_on_red_hat_openshift_container_platform
:URL_CONFIGURATION_QUARKUS: {URL_BASE_QUARKUS}/configuring_quarkus_applications
:URL_TESTING_QUARKUS: {URL_BASE_QUARKUS}/testing_your_quarkus_getting_started_project
:URL_NATIVE_EXECUTABLE_QUARKUS: {URL_BASE_QUARKUS}/building_a_native_executable_with_{URL_COMPONENT_PRODUCT}

//External URLs
:URL_OPENSHIFT_INSTALLING: https://access.redhat.com/documentation/en-us/openshift_container_platform/4.3/html-single/installing/index

= Deploying Quarkus applications on {RHOSLong}

:context: quarkus-openshift
//include::_artifacts/author-group.adoc[]


As an application developer, you can deploy a {ProductName} application on {RHOSLong} using Apache Maven and the `quarkus-openshift` extension in a single build command or you can use the traditional source-to-image (S2I) method. The resulting image from either method is fully supported. See the https://access.redhat.com/support/offerings/developer/soc/[Development Support Scope of Coverage] page for the build process and tools that are covered under development support.

You can deploy a {ProductName} application compiled to a native executable using OpenShift Serverless Knative Serving and scale services up or down. Scaling down services can improve memory capabilities.



.Prerequisites

* OpenJDK {JDKVersion} is installed and the `JAVA_HOME` environment variable specifies the location of the Java SDK. Red Hat build of Open JDK is available from the https://access.redhat.com/jbossnetwork/restricted/listSoftware.html[Software Downloads] page in the Red Hat Customer Portal (login required).
* Apache Maven {MavenVersion} or higher is installed. Maven is available from the https://maven.apache.org/[Apache Maven Project] website.
* You have a Quarkus Maven project. For instructions on building a simple Quarkus application with Maven, see {URL_GETTING_STARTED_QUARKUS}[_{GETTING_STARTED_QUARKUS}_].
+
NOTE: For a completed example of a Quarkus Maven project, download the https://github.com/quarkusio/quarkus-quickstarts/archive/{ProductLongVersion}.Final.zip[Quarkus quickstart archive] or clone the `Quarkus Quickstarts` Git repository. The example is in the `getting-started` directory.
* You have access to a {RHOSLong} cluster and the latest version of the OpenShift CLI (oc) is installed. For information about installing oc, see the "Installing the CLI" section of the https://access.redhat.com/documentation/en-us/openshift_container_platform/4.3/html-single/installing/index[_Installing and configuring OpenShift Container Platform clusters_] guide.


:leveloffset: +1

[id="con-quarkus_{context}"]

= {ProductLongName}

{ProductLongName} is a Kubernetes-native Java stack that is optimized for use with containers and {RHOSLong}. {ProductName} is designed to work with popular Java standards, frameworks, and libraries such as Eclipse MicroProfile, Apache Kafka, RESTEasy (JAX-RS), Hibernate ORM (JPA), Spring, Infinispan, and Apache Camel.

The {ProductName} dependency injection solution is based on CDI (contexts and dependency injection) and includes an extension framework to expand functionality and to configure, boot, and integrate a framework into your application.

{ProductName} provides a container-first approach to building Java applications. This approach makes it much easier to build microservices-based applications written in Java as well as enabling those applications to invoke functions running on serverless computing frameworks. For this reason, {ProductName} applications have small memory footprints and fast startup times.

:leveloffset!:

:leveloffset: +1

[id='con-openshift_{context}']


= {RHOSLong}

{RHOSLong} is a Kubernetes-based platform for developing and running containerized applications. It is designed to enable applications and the data centers that support them to expand from just a few systems and applications to thousands of systems that serve millions of clients.

OpenShift supports two workflows for building container images for applications: the source and the binary workflows.  Both workflows are based on the source-to-image (S2I) feature and both workflows rely on S2I builds using the source workflow. The key difference is that the source workflow generates deployable artifacts of your application inside OpenShift, while the binary workflow generates these binary artifacts outside of OpenShift. Both of them build the application container image inside OpenShift. The binary workflow provides an application binary as the source for an OpenShift S2I build that generates a container image.

:leveloffset!:

:leveloffset: +1

[id="proc-using-openshfit-extension_{context}"]

= Using the Quarkus OpenShift extension to deploy Quarkus applications on OpenShift


The traditional source-to-image (S2I) source workflow generates the deployable artifacts of your application inside OpenShift. The Quarkus OpenShift extension uses the S2I binary workflow to provide a more streamlined deployment process. Instead of building from the source, the extension uploads the JAR files from the local file system. As a result, the build process is up to ten times faster than the traditional S2I method. You can use the Quarkus OpenShift extension when developing locally as well as from a build server or continuous integration (CI) system to perform repeatable builds from source.

NOTE: Use the Quarkus OpenShift extension for development and testing purposes only. For production environments, consider using the traditional S2I method described in xref:proc-using-s2i-openshift-quarkus_{context}[].

.Procedure

. Change to the directory that contains your Quarkus Maven project.

. To add the OpenShift extension to an existing project, enter the following command:
+
[source, subs=attributes+]
----
./mvnw quarkus:add-extension -Dextensions="openshift"
----
+
NOTE: You can include the `-Dextensions="openshift"` argument to add the Quarkus OpenShift extension when you create a new project.
+
When you add the OpenShift extension, the script adds the following dependency to the `pom.xml` file:
+
[source,xml]
----
   <dependency>
     <groupId>io.quarkus</groupId>
     <artifactId>quarkus-openshift</artifactId>
   </dependency>
----
. If you are using an untrusted certificate, add the following line to the `src/main/resources/application.properties` file:
+
[source]
----
quarkus.kubernetes-client.trust-certs=true
----

. To direct OpenShift to use the Open JDK {JDKVersion} {RHEL} 7 image, add the following line to the `application.properties` file:
+
[source,xml]
----
quarkus.s2i.base-jvm-image=registry.access.redhat.com/openjdk/openjdk-11-rhel7
----
+
NOTE: If you are deploying on IBM Z infrastructure, add `quarkus.s2i.base-jvm-image=registry.access.redhat.com/openj9/openj9-11-rhel8` to the `application.properties` file.
. To create an OpenShift route, add the following line to the `application.properties` file:
+
[source]
----
quarkus.openshift.expose=true
----
. Save the changes to the `application.properties` file.
. Log in to the OpenShift CLI (oc):
+
[source]
----
oc login
----
. To create a new OpenShift project, enter the following command where `_PROJECT_NAME_` is the name of your new project:
+
[source,xml,subs="attributes+,+quotes"]
----
oc new-project __PROJECT_NAME__
----
. To deploy your project to OpenShift, enter the following command in your Quarkus Maven project directory:
+
[source]
----
./mvnw clean package -Dquarkus.kubernetes.deploy=true
----
. To display the names and routes of all deployed applications in the OpenShift project, enter the following command:
+
[source,xml,subs="attributes+,+quotes"]
----
oc get route
----
. To view the full URL to the application, where `_APPLICATION_NAME_` is the name of an application deployed in your OpenShift project, enter the following command:
+
[source,xml,subs="attributes+,+quotes"]]
----
export URL="http://$(oc get route __APPLICATION_NAME__ -o jsonpath='{.spec.host}')"
echo "Application URL: $URL"
curl $URL/hello
----
. To create an HTTP request on the route's `hello` endpoint, enter the following command:
+
[source,xml,subs="attributes+,+quotes"]]
----
curl $URL/hello
----

:leveloffset!:

:leveloffset: +1

[id="proc-using-s2i-openshift-quarkus_{context}"]

= Using S2I to deploy Quarkus applications on OpenShift

The traditional source-to-image (S2I) method is widely used as the preferred method for deploying applications on {RHOSLong}.  With S2I, you must provide the source code to the build container either through a Git repository or by uploading the source at build time. Use this method to deploy your Quarkus applications in production environments.

.Prerequisites
* You have a Quarkus Maven project hosted in a Git repository.

.Procedure

. Change to the directory that contains your Quarkus Maven project.
. Create a hidden directory called `.s2i` at the same level as the `pom.xml` file.
. Create a file called `environment` in the `.s2i` directory and add the following content:
+
[source]
----
ARTIFACT_COPY_ARGS=-p -r lib/ *-runner.jar
----
. Commit and push your changes to the remote Git repository.
. Log in to the OpenShift CLI (oc):
+
[source]
----
oc login
----
. To create a new OpenShift project, enter the following command where `_PROJECT_NAME_` is the name of your new project:
+
[source,xml,subs="attributes+,+quotes"]
----
oc new-project __PROJECT_NAME__
----
. To import the supported OpenShift image, enter the following command:
+
[source]
----
﻿oc import-image --confirm openjdk/openjdk-11-rhel7 --from=registry.access.redhat.com/openjdk/openjdk-11-rhel7
----
NOTE: If you are deploying on IBM Z infrastructure, enter `﻿oc import-image --confirm openj9/openj9-11-rhel8 --from=registry.redhat.io/openj9/openj9-11-rhel8`.
+
For information about this image, see the https://catalog.redhat.com/software/containers/openj9/openj9-11-rhel8/5ddfdb765a13461646f816f0[Red Hat OpenJ9 11 Java Applications on RHEL8] page.

. To build the project in OpenShift, enter the following command where `_GIT_PATH_` is the path to the Git repository that hosts your Quarkus project and `_PROJECT_NAME_` is the OpenShift project that you created.
+
[source,xml,subs="attributes+,+quotes"]
----
oc new-app openjdk-11-rhel7 __GIT_PATH__ --name=__PROJECT_NAME__
----
NOTE: If you are deploying on IBM Z infrastructure, enter `﻿oc new-app openj9/openj9-11-rhel8 __GIT_PATH__ --name=__PROJECT_NAME__`.
+
This command builds the project, creates the application, and deploys the OpenShift service.

. To create an OpenShift route, enter the following command:
+
[source,xml,subs="attributes+,+quotes"]
----
oc expose service/__PROJECT_NAME__
----
. To view the new route, enter the following command where `_APPLICATION_NAME_` is the name of an application deployed in your OpenShift project:
+
[source,xml,subs="attributes+,+quotes"]
----
export URL="http://$(oc get route __APPLICATION_NAME__ -o jsonpath='{.spec.host}}')"
echo "Application URL: $URL"
----

. To create an HTTP request on the route's `hello` endpoint, enter the following command:
+
[source,xml,subs="attributes+,+quotes"]]
----
curl $URL/hello
----

. To use your application, enter the URL returned in the preceding command in a web browser.
. To deploy an updated version of the project, push any updates to the Git repository then enter the following command:
+
[source,xml,subs="attributes+,+quotes"]
----
oc start-build __PROJECT_NAME__
----
. Refresh your browser page after the build completes to see the changes.

:leveloffset!:

:leveloffset: +1

[id="con-deploying-quarkus-serverless"]

= Deploying a {ProductName} application compiled to a native executable as a OpenShift Serverless service

As an application developer, you can deploy a {ProductName} application compiled to a native executable on Red Hat OpenShift Container Platform using OpenShift Serverless Knative Serving.

By using OpenShift Serverless Knative Serving, you can scale services up and down depending on the load size. Scaling down services that are currently not requested improves memory capabilities.

NOTE: You can run {ProductName} as a native executable or as a Java application using OpenJDK. For native executables, use the Red Hat UBI 8 minimal image. For OpenJDK, use the Red Hat 8 UBI Java image.

:leveloffset!:

:leveloffset: +2

[id='proc-deploy-container-image-quarkus-native_{context}']

= Deploying a container image for a {ProductName} native application in a continuous integration as a serverless application

You can separate the native build, container build, and deployment steps when deploying a native serverless application. The following procedure demonstrates how to deploy a container image for a {ProductName} native application in a continuous integration (CI) as a serverless application.

.Prerequisites
//* You have a {ProductName} Maven project.
* OpenShift Serverless operator is installed.
* OpenShift Knative Serving is installed.
//* You have access to a Red Hat OpenShift Container Platform cluster and the latest version of the OpenShift CLI (oc) is installed.
//* OpenJDK 11 is installed and the `JAVA_HOME` environment variable specifies the location of the Java SDK.
//* Apache Maven 3.6.2 or higher is installed. Maven is available from the Apache Maven Project website.
* For native compilation, a container environment like Podman or Docker is required.
* The `kn` CLI tool is installed.

.Procedure

. Change to the directory that contains your {ProductName} project.
. Build a Linux executable using one of the following methods:

.. For Docker use:
+
[source]
----
./mvnw package -Pnative -Dquarkus.native.container-build=true -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:20.1.0.1.Final-java11
----
+
.. For Podman use:
+
[source]
----
./mvnw package -Pnative -Dquarkus.native.container-build=true -Dquarkus.native.container-runtime=podman -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:20.1.0.1.Final-java11
----
+
. Open the `src/main/docker/Dockerfile.native` file and set the `<IMAGE_NAME>` and `<VERSION>` parameters:

.. For Docker use:
+
[source]
----
docker build -f src/main/docker/Dockerfile.native -t <IMAGE_NAME>:<VERSION> .
----
+
.. For Podman use:
+
[source]
----
podman build -f src/main/docker/Dockerfile.native -t <IMAGE_NAME>:<VERSION>.
----
. Push the container to a repository that your CI environment and your OpenShift environment can access, where `<REGISTRY>` is your registry URL:

.. For Docker use:
+
[source]
----
docker tag <IMAGE_NAME>:<VERSION> <REGISTRY>/<IMAGE_NAME>:<VERSION>
docker push <REGISTRY>/<IMAGE_NAME>:<VERSION>
----
+
.. For Podman use:
+
[source]
----
podman tag <IMAGE_NAME>:<VERSION> <REGISTRY>/<IMAGE_NAME>:<VERSION>
podman push <REGISTRY>/<IMAGE_NAME>:<VERSION>
----
+
. Log in to the OpenShift CLI (oc):
+
[source]
----
oc login
----
+
. To create a new OpenShift project, enter the following command where `<PROJECT_NAME>` is the name of your new project:
+
[source]
----
oc new-project <PROJECT_NAME>
----
+
. To deploy your container as a serverless application using the OpenShift Serverless CLI (kn), enter the following command where `<SERVICE_NAME>` is the name for your service:
+
[source]
----
kn service create <SERVICE_NAME> --image REPOSITORY/<IMAGE_NAME>:<VERSION>
----
+
. To verify that the service is ready, enter the following command.
+
[source]
----
kn service list SERVICE_NAME
----
+
The output in the column called "READY" reads `true` if the service is ready.

NOTE: The `kn service` command returns `true` when the necessary components are created, not when the image is pulled down and ready.




:leveloffset!:

== Additional resources
* For  information about creating {PRODUCTNAME} applications with Maven, see link:{URL_MAVEN_QUARKUS}[_{MAVEN_QUARKUS}_].
* For more information on how to compile the {ProductName} applications to native executables and native executable testing, see link:{URL_NATIVE_EXECUTABLE_QUARKUS}[_{NATIVE_EXECUTABLE_QUARKUS}_]


// Versioning info
////
Revision information template.
Add this to the end of every document.
////

_Revised on {localdate} {localtime}_
